import os
import json
import random
import sys
from google import genai
from google.genai import types
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Initialize the Gemini client (uses GEMINI_API_KEY from .env)
try:
    client = genai.Client()
except Exception as e:
    print(f"‚ùå Error initializing Gemini Client: {e}")
    client = None

# ---- SHARED CONFIGURATION ----
MODEL_NAME_CONVERSATION = "gemini-2.5-pro"  # Robust for strict, complex output
MODEL_NAME_PODCAST = "gemini-2.5-pro"      # Good for instructional, fast output
NUM_CONVERSATION_IDEAS = 10
NUM_PODCAST_IDEAS = 3

# Consolidated Voice Pool (Used for CONVERSATIONS only)
VOICES = [
    {
        "name": "Aurora Voice",
        "gender": "female",
        "age": "young adult",
        "description": "Young Finnish friendly and professional voice. Perfect for conversations and narration.",
        "voice_id": "YSabzCJMvEHDduIDMdwV",
    },
    {
        "name": "Jussi - Strong finnish Accent",
        "gender": "male",
        "age": "young adult",
        "description": "Finnish young male voice with a hilariously strong accent! This simple Finnish man delivers lines in classic rally English, blending a thick Finnish accent with a silly, light-hearted tone.",
        "voice_id": "dlbXHgJnwobU5JdZ8F5M",
    },
    {
        "name": "Mark - ConvoAI",
        "gender": "male",
        "age": "adult",
        "description": "soft and calm",
        "voice_id": "1SM7GgM6IMuvQlz2BwM3",
    },
    {
        "name": "ScheilaSMTy",
        "gender": "female",
        "description": "Middle aged Brazilian female. Crisp, carefully articulated, flowing with a smooth, engaging cadence.",
        "voice_id": "cyD08lEy76q03ER1jZ7y",
    },
    {
        "name": "Rahul Bharadwaj - Highly Energetic Voice",
        "gender": "male",
        "age": "middle-aged",
        "description": "Middle-aged Indian with a velvety, laid-back timbre, brimming with energy.",
        "voice_id": "u7bRcYbD7visSINTyAT8",
    },
    {
        "name": "Grandpa Spuds Oxley",
        "gender": "male",
        "age": "senior",
        "description": "A friendly grandpa who knows how to enthrall his audience with tall tales and fun adventures.",
        "voice_id": "NOpBlnGInO9m6vDvFkFC",
    },
    {
        "name": "Hope - Smooth talker",
        "gender": "female",
        "age": "adult",
        "description": "A conversational, soft-spoken, sultry, and romantic voice with a vocal fry.",
        "voice_id": "1SM7GgM6IMuvQlz2BwM3",
    },
]

# --- PODCAST-SPECIFIC VOICE LIST ---
ALLOWED_PODCAST_CHARACTERS = [
    {
        "name": "Aurora",
        "gender": "female",
        "age": "young adult",
        "voice_id": "YSabzCJMvEHDduIDMdwV",
    },
    {
        "name": "Jussi",
        "gender": "male",
        "age": "young adult",
        "voice_id": "dlbXHgJnwobU5JdZ8F5M",
    },
]

# --- VOICE ASSIGNMENT HELPERS ---

def assign_voice_ids(ideas_list, key="characters"):
    """
    Assigns a voice_id from the *full* VOICES pool based on gender.
    Used for Conversation Ideas.
    """
    for idea in ideas_list:
        for char in idea.get(key, []):
            gender = char.get("gender", "unknown").lower()
            age = char.get("age", "").lower()
            # Prefer voices that match both gender and age, then gender only, then any voice
            matching = []
            if age:
                matching = [v for v in VOICES if v.get("gender", "").lower() == gender and v.get("age", "").lower() == age]
            if not matching:
                matching = [v for v in VOICES if v.get("gender", "").lower() == gender]
            voice = random.choice(matching) if matching else random.choice(VOICES)
            char["voice_id"] = voice["voice_id"]
    return ideas_list

# **NEW FUNCTION FOR PODCAST VOICES**
def assign_podcast_voice_ids(ideas_list, key="characters"):
    """
    Assigns voice_id ONLY from the ALLOWED_PODCAST_CHARACTERS list.
    It matches the character's *name* generated by the LLM to the voice_id.
    """
    # Create a mapping for quick lookup: Name -> voice_id
    voice_map = {v["name"].lower(): v["voice_id"] for v in ALLOWED_PODCAST_CHARACTERS}
    
    for idea in ideas_list:
        for char in idea.get(key, []):
            char_name = char.get("name", "").lower()
            
            # Find the voice ID based on the character's name generated by the model
            voice_id = voice_map.get(char_name)
            
            # Assign the voice_id if a match is found
            if voice_id:
                char["voice_id"] = voice_id
            else:
                # Fallback: If the model uses a name not in the list (violating the prompt), 
                # assign a random voice from the *allowed* list to ensure a voice_id is present.
                # This helps prevent runtime errors, but the prompt should ideally prevent this.
                print(f"‚ö†Ô∏è Warning: Character name '{char_name}' not found in allowed podcast voices. Assigning random allowed voice.")
                char["voice_id"] = random.choice(ALLOWED_PODCAST_CHARACTERS)["voice_id"]
                
    return ideas_list

# --- 1. CONVERSATION IDEAS LOGIC (No Change) ---

# Schema for Conversations (2 characters strictly)
CONVERSATION_SCHEMA = types.Schema(
    type="object",
    properties={
        "metadata": types.Schema(
            type="object",
            properties={
                "language": types.Schema(type="string"),
                "tone": types.Schema(type="string"),
                "length": types.Schema(type="string"),
            },
            required=["language", "tone", "length"],
        ),
        "ideas": types.Schema( # Key: 'ideas'
            type="array",
            items=types.Schema(
                type="object",
                properties={
                    "title": types.Schema(type="string"),
                    "description": types.Schema(type="string"),
                    "characters": types.Schema(
                        type="array",
                        min_items=2,
                        max_items=2,
                        items=types.Schema(
                            type="object",
                            properties={
                                "name": types.Schema(type="string"),
                                "gender": types.Schema(type="string"),
                                "age": types.Schema(type="string"),
                                "default_tone": types.Schema(type="string"),
                            },
                            required=["name", "gender", "age", "default_tone"],
                        ),
                    ),
                },
                required=["title", "description", "characters"],
            ),
        ),
    },
    required=["metadata", "ideas"],
)

CONVERSATION_SYSTEM_PROMPT = """You are a creative idea generator for short Finnish conversations.
You must output STRICTLY in JSON format.

Rules:
- Each idea can have 2 or more characters.
- One conversation must not have the same character more than once.
- Dialogues must be suitable for beginners learning Finnish.
- Each idea must be creative, fun, and immediately useful for a beginner.
- Use realistic Finnish names and situations (e.g., caf√©s, trams, offices, home).
- The gender and age of each character must be specified and matched to a voice.
- Only fill in the string values.
"""

def generate_conversation_ideas():
    print(f"ü™Ñ Generating {NUM_CONVERSATION_IDEAS} general conversation ideas...")
    if not client: return None

    config = types.GenerateContentConfig(
        system_instruction=CONVERSATION_SYSTEM_PROMPT,
        response_mime_type="application/json",
        response_schema=CONVERSATION_SCHEMA
    )

    full_prompt = (
        f"Generate {NUM_CONVERSATION_IDEAS} unique ideas for short Finnish conversations, following the specified JSON structure exactly."
    )

    response = client.models.generate_content(
        model=MODEL_NAME_CONVERSATION,
        contents=[full_prompt],
        config=config,
    )

    data = json.loads(response.text)
    data["ideas"] = assign_voice_ids(data.get("ideas", []))
    return data, "ideas.json"

# --- 2. PODCAST IDEAS LOGIC (Minor Changes to System Prompt and Function) ---

# Schema for Podcast Ideas (1 or 2 characters, different metadata keys)
PODCAST_SCHEMA = types.Schema(
    type="object",
    properties={
        "metadata": types.Schema(
            type="object",
            properties={
                "target_audience": types.Schema(type="string", description="e.g., Absolute Beginner"),
                "duration": types.Schema(type="string", description="e.g., 3-5 minutes"),
                "format": types.Schema(type="string", description="e.g., Solo or Host/Guest"),
            },
            required=["target_audience", "duration", "format"],
        ),
        "podcast_ideas": types.Schema( # Key: 'podcast_ideas'
            type="array",
            items=types.Schema(
                type="object",
                properties={
                    "title": types.Schema(type="string", description="Catchy episode title."),
                    "concept": types.Schema(type="string", description="Brief summary of the tip or phrases taught."),
                    "characters": types.Schema(
                        type="array",
                        min_items=1, # Min 1 character
                        max_items=2, # Max 2 characters
                        items=types.Schema(
                            type="object",
                            properties={
                                "name": types.Schema(type="string"),
                                "role": types.Schema(type="string", description="Host, Guest, or Solo Presenter"),
                                "gender": types.Schema(type="string"),
                                "age": types.Schema(type="string"),
                                "default_tone": types.Schema(type="string"),
                            },
                            required=["name", "role", "gender", "age", "default_tone"],
                        ),
                    ),
                },
                required=["title", "concept", "characters"],
            ),
        ),
    },
    required=["metadata", "podcast_ideas"],
)

# Updated System Prompt to explicitly mention allowed characters to guide the LLM
PODCAST_SYSTEM_PROMPT = f"""You are a highly creative script idea generator for short (3-5 minute) educational podcasts aimed at absolute beginners learning Finnish.
The ideas must focus on either a single, highly useful beginner Finnish tip (e.g., a grammar shortcut, a cultural concept, or a pronunciation trick) OR a small set of immediately useful phrases for a specific situation.
The podcast can be a 'Solo Host' (1 character) or 'Host and Guest' (2 characters).
You must output STRICTLY in JSON format.

Rules:
- Each idea must be creative, fun, and immediately useful for a beginner.
- Use realistic Finnish names and describe the character roles (Host, Guest, or Solo Presenter).
-- The gender and age of each character must be specified and matched to a voice.
- **CRITICAL:** The character names in the 'characters' array MUST be chosen ONLY from this approved list of names: {', '.join([c['name'] for c in ALLOWED_PODCAST_CHARACTERS])}.
- The 'title' should be catchy and podcast-friendly.
- Only fill in the string values.
"""

def generate_podcast_ideas():
    print(f"ü™Ñ Generating {NUM_PODCAST_IDEAS} podcast lesson ideas...")
    if not client: return None

    config = types.GenerateContentConfig(
        system_instruction=PODCAST_SYSTEM_PROMPT,
        response_mime_type="application/json",
        response_schema=PODCAST_SCHEMA
    )

    full_prompt = (
        f"Generate {NUM_PODCAST_IDEAS} unique, creative, and highly useful podcast ideas for Finnish beginners, following the specified JSON structure exactly. Remember to use only the allowed character names."
    )

    response = client.models.generate_content(
        model=MODEL_NAME_PODCAST,
        contents=[full_prompt],
        config=config,
    )

    data = json.loads(response.text)
    # **MODIFICATION HERE**: Use the new specific voice assignment function
    data["podcast_ideas"] = assign_podcast_voice_ids(data.get("podcast_ideas", [])) 
    return data, "podcast_ideas.json"

# --- MAIN EXECUTION (No Change) ---

def main():
    if not client:
        print("üõë Cannot run generation. Please ensure 'google-genai' is installed and 'GEMINI_API_KEY' is set in your .env file.")
        return

    # Check for command-line argument
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'podcast':
        result, output_file = generate_podcast_ideas()
        idea_count = NUM_PODCAST_IDEAS
    else:
        # Default behavior: generate conversations
        result, output_file = generate_conversation_ideas()
        idea_count = NUM_CONVERSATION_IDEAS

    if result:
        try:
            with open(output_file, "w", encoding="utf-8") as f:
                json.dump(result, f, ensure_ascii=False, indent=2)
            print(f"‚úÖ {idea_count} ideas saved to **{output_file}**")
        except Exception as e:
            print(f"‚ùå An error occurred while saving the file: {e}")

if __name__ == "__main__":
    main()